"""
Django settings for core project.

Generated by 'django-admin startproject' using Django 5.x.
Modified for: PostgreSQL, Redis cache, DRF, CORS, and the housing app.
"""

from pathlib import Path
import os
import dj_database_url
import cloudinary
import cloudinary.uploader
import cloudinary.api

# =============================================================================
# 1. BASE DIRECTORY
# Everything below that uses file paths references this.
# =============================================================================
BASE_DIR = Path(__file__).resolve().parent.parent


# =============================================================================
# 2. SECURITY
# SECRET_KEY must never be hardcoded in production.
# For this series (development only), we keep it inline.
# In a production part of this series, we'll move it to an env variable.
# =============================================================================
SECRET_KEY = "django-insecure-change-this-in-production"

# DEBUG = True means detailed error pages. Never True in production.
DEBUG = True

# ALLOWED_HOSTS controls which hostnames Django will serve.
# '*' means "any hostname". Fine for development. Locked down in production.
ALLOWED_HOSTS = ["*"]


# =============================================================================
# 3. INSTALLED APPS
# This is the registration desk. If an app isn't listed here, Django doesn't
# know it exists — its models won't migrate, its templates won't load,
# its management commands won't run.
#
# Order matters for some things (corsheaders must be early).
# We group by: Django internals → third-party → our apps.
# =============================================================================
INSTALLED_APPS = [
    # --- Django internals (don't touch these) ---
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "cloudinary_storage",
    "django.contrib.staticfiles",
    # --- Third-party (installed via pip, registered here) ---
    "rest_framework",  # Django REST Framework — the API layer
    "corsheaders",  # CORS — lets Next.js on :3000 talk to this on :8000
    "debug_toolbar",
    "django_filters",
    # --- Our apps ---
    "housing",  # The housing portal domain app
]


# =============================================================================
# 4. MIDDLEWARE
# Middleware is a stack of functions that process every request and response.
# Order is critical. The request goes DOWN this list. The response goes back UP.
#
# CorsMiddleware MUST be above CommonMiddleware.
# If it's below, the CORS headers get added after CommonMiddleware has already
# decided to reject the request. The browser never sees them.
# =============================================================================
MIDDLEWARE = [
    "debug_toolbar.middleware.DebugToolbarMiddleware",
    "django.middleware.security.SecurityMiddleware",
    "corsheaders.middleware.CorsMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]


# =============================================================================
# 5. URL CONFIGURATION
# Points Django to the file that defines all URL routes.
# =============================================================================
ROOT_URLCONF = "core.urls"


# =============================================================================
# 6. TEMPLATES
# How Django finds and renders HTML templates.
# We're using an API-first approach (DRF + Next.js), so templates are mostly
# for the admin panel. But they still need to be configured or admin breaks.
# =============================================================================
TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]


# =============================================================================
# 7. WSGI APPLICATION
# The entry point for production WSGI servers (gunicorn, uwsgi).
# We're using Django's dev server now. This matters in a later part.
# =============================================================================
WSGI_APPLICATION = "core.wsgi.application"


# =============================================================================
# 8. DATABASE
# This is where the Part 1 DATABASE_URL finally gets used.
#
# dj_database_url.config() does two things:
#   - Reads the DATABASE_URL environment variable
#   - Parses the postgres:// URL into the dictionary Django expects
#
# The 'default' key is a fallback. If DATABASE_URL is missing (e.g., someone
# runs this outside Docker), it falls back to SQLite so Django doesn't crash.
# Inside Docker, DATABASE_URL is always set. The fallback never triggers.
#
# conn_max_age=600 keeps database connections alive for 10 minutes instead of
# opening a new one per request. This is connection pooling lite — a small
# performance win that becomes significant under load.
# =============================================================================
DATABASES = {
    "default": dj_database_url.config(
        default="sqlite:///db.sqlite3",
        conn_max_age=600,
    )
}


# =============================================================================
# 9. CACHE
# This is where Redis actually becomes useful to Django.
#
# We're using Django's built-in RedisCache backend (added in Django 4.0).
# It reads REDIS_URL from the environment — the variable we added to
# docker-compose.yml in Part 1.
#
# The fallback ('redis://redis:6379') is the default Docker service name.
# If REDIS_URL isn't set, it assumes we're inside Docker and tries the
# service name directly.
#
# OPTIONS → CLIENT_CLASS points to django-redis's client, which adds
# connection pooling and retry logic on top of the raw Redis connection.
# =============================================================================
CACHES = {
    "default": {
        # "BACKEND": "django.core.cache.backends.redis.RedisCache", # Django 5.0's built-in Redis backend
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": os.environ.get("REDIS_URL", "redis://redis:6379"),
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        },
    }
}


# =============================================================================
# 10. CORS CONFIGURATION
# Cross-Origin Resource Sharing. The browser enforces this, not the server.
# But the server has to send the right headers or the browser blocks the call.
#
# CORS_ALLOWED_ORIGINS is a whitelist. Only these origins can make requests
# to this API. In development, that's just Next.js on localhost:3000.
# In production, this becomes your actual domain.
# =============================================================================
CORS_ALLOWED_ORIGINS = [
    "http://localhost:3000",  # Next.js dev server
]


# =============================================================================
# 11. AUTH / PASSWORD VALIDATORS
# Django's built-in password strength checks for the admin panel.
# Kept as-is. Not relevant to the caching series but removing them
# would break the admin user creation flow.
# =============================================================================
AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator"
    },
    {"NAME": "django.contrib.auth.password_validation.MinimumLengthValidator"},
    {"NAME": "django.contrib.auth.password_validation.CommonPasswordValidator"},
    {"NAME": "django.contrib.auth.password_validation.NumericPasswordValidator"},
]


# =============================================================================
# 12. INTERNATIONALIZATION
# =============================================================================
LANGUAGE_CODE = "en-us"
TIME_ZONE = "UTC"
USE_I18N = True
USE_TZ = True


# =============================================================================
# 13. STATIC FILES
# Where Django serves CSS/JS for the admin panel.
# =============================================================================
STATIC_URL = "static/"


# =============================================================================
# 14. DEFAULT AUTO FIELD
# Django needs to know what type of primary key to generate for new models
# if you don't specify one explicitly. BigAutoField = 64-bit integer.
# Handles up to 9.2 quintillion rows. Probably enough.
# =============================================================================
DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"


# =============================================================================
# 15. REST FRAMEWORK
# DRF's global settings. We're keeping defaults for now.
# In a later part, we'll add pagination here — which is itself a caching
# surface (paginated responses are much more cacheable than "give me everything").
# =============================================================================
REST_FRAMEWORK = {
    "DEFAULT_PAGINATION_CLASS": "rest_framework.pagination.PageNumberPagination",
    "PAGE_SIZE": 20,
}

LOGGING = {
    "version": 1,
    "handlers": {"console": {"class": "logging.StreamHandler"}},
    "loggers": {"django.db.backends": {"level": "DEBUG", "handlers": ["console"]}},
}

# This allows the toolbar to show up when running in Docker
INTERNAL_IPS = [
    "127.0.0.1",
]

import socket

hostname, _, ips = socket.gethostbyname_ex(socket.gethostname())
INTERNAL_IPS += [ip[:-1] + "1" for ip in ips]

"""
- Reads the Cloudinary credentials from environment variables
- Configures the SDK with those credentials
- Sets `DEFAULT_FILE_STORAGE` so any Django `ImageField` or `FileField` automatically uploads to Cloudinary instead of saving to local disk
"""

CLOUDINARY_STORAGE = {
    "CLOUD_NAME": os.environ.get("CLOUDINARY_CLOUD_NAME"),
    "API_KEY": os.environ.get("CLOUDINARY_API_KEY"),
    "API_SECRET": os.environ.get("CLOUDINARY_API_SECRET"),
}


cloudinary.config(
    cloud_name=CLOUDINARY_STORAGE["CLOUD_NAME"],
    api_key=CLOUDINARY_STORAGE["API_KEY"],
    api_secret=CLOUDINARY_STORAGE["API_SECRET"],
    secure=True,  # Use HTTPS
)

DEFAULT_FILE_STORAGE = "cloudinary_storage.storage.MediaCloudinaryStorage"
